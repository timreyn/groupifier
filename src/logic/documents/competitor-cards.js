import { chunk, sortBy, times, zip } from '../utils';
import { eventNameById } from '../events';
import {
  activityById,
  hasDistributedAttempts,
  parseActivityCode,
  roomForActivity,
} from '../activities';
import { acceptedPeople } from '../competitors';
import { getExtensionData } from '../wcif-extensions';
import pdfMake from './pdfmake';
import { pdfName } from './pdf-utils';

export const downloadCompetitorCards = (wcif, evenlySpaced = false) => {
  const pdfDefinition = evenlySpaced
    ? competitorCardsEvenlySpacedPdfDefinition(wcif)
    : competitorCardsPdfDefinition(wcif);
  pdfMake.createPdf(pdfDefinition).download(`${wcif.id}-competitor-cards.pdf`);
};

const competitorCardsPdfDefinition = wcif => ({
  pageMargins: [5, 5],
  content: chunk(competitorCards(wcif, 3), 3).map(cards => ({
    columns: cards,
    margin: [5, 5],
    columnGap: 10,
    fontSize: 8,
    unbreakable: true,
  })),
});

const competitorCardsEvenlySpacedPdfDefinition = wcif => {
  const pageWidth = 595.28;
  const pageHeight = 841.89;
  const cardsPerRow = 2;
  const horizontalMargin = 20;
  const verticalMargin = 20;

  const cutLines = {
    canvas: [
      cutLine({
        x1: horizontalMargin,
        y1: pageHeight / 2,
        x2: pageWidth - horizontalMargin,
        y2: pageHeight / 2,
      }),
      cutLine({
        x1: pageWidth / 2,
        y1: verticalMargin,
        x2: pageWidth / 2,
        y2: pageHeight - verticalMargin,
      }),
    ],
  };

  return {
    pageSize: { width: pageWidth, height: pageHeight },
    pageMargins: [horizontalMargin, verticalMargin],
    background: [cutLines],
    content: {
      fontSize: 8,
      layout: {
        /* Outer margin is done using pageMargins, we use padding for the remaining inner margins. */
        paddingLeft: i => (i % cardsPerRow === 0 ? 0 : horizontalMargin),
        paddingRight: i =>
          i % cardsPerRow === cardsPerRow - 1 ? 0 : horizontalMargin,
        paddingTop: i => (i % cardsPerRow === 0 ? 0 : verticalMargin),
        paddingBottom: i =>
          i % cardsPerRow === cardsPerRow - 1 ? 0 : verticalMargin,
        /* Get rid of borders. */
        hLineWidth: () => 0,
        vLineWidth: () => 0,
      },
      table: {
        widths: Array(cardsPerRow).fill('*'),
        heights: pageHeight / cardsPerRow - 2 * verticalMargin,
        dontBreakRows: true,
        body: chunk(competitorCards(wcif, cardsPerRow), cardsPerRow),
      },
    },
  };
};

const cutLine = properties => ({
  ...properties,
  type: 'line',
  lineWidth: 0.1,
  dash: { length: 10 },
  lineColor: '#888888',
});

const competitorCards = (wcif, cardsPerRow) => {
  const cards = sortBy(
    acceptedPeople(wcif),
    person => person.name
  ).map(person => competitorCard(wcif, person));
  const cardsInLastRow = cards.length % cardsPerRow;
  return cardsInLastRow === 0
    ? cards
    : cards.concat(times(cardsPerRow - cardsInLastRow, () => ({})));
};

const competitorCard = (wcif, person) => {
  const events = wcif.events.filter(event => !hasDistributedAttempts(event.id));
  const { localNamesFirst } = getExtensionData('CompetitionConfig', wcif) || {
    localNamesFirst: false,
  };
  const tasks = sortBy(
    person.assignments
      .map(({ activityId, assignmentCode }) => {
        const activity = activityById(wcif, activityId);
        const { eventId, roundNumber, groupNumber } = parseActivityCode(
          activity.activityCode
        );
        const room = roomForActivity(wcif, activityId);
        return { assignmentCode, eventId, groupNumber, roundNumber, room };
      })
      .filter(({ roundNumber }) => roundNumber === 1),
    ({ groupNumber }) => groupNumber
  );
  const groupsText = (eventId, assignmentCode) => ({
    text: tasks
      .filter(
        task =>
          task.eventId === eventId && task.assignmentCode === assignmentCode
      )
      .map(task => task.room.name[0] + task.groupNumber)
      .join(', '),
    alignment: 'center',
  });
  const [assignmentCodes = [], headers = []] = zip(
    ...[
      ['competitor', 'Comp'],
      ['staff-scrambler', 'Scr'],
      ['staff-runner', 'Run'],
      ['staff-judge', 'Judge'],
    ].filter(([assignmentCode]) =>
      tasks.some(task => task.assignmentCode === assignmentCode)
    )
  );
  return {
    stack: [
      {
        text: pdfName(person.name, {
          swapLatinWithLocalNames: localNamesFirst,
        }),
        fontSize: 10,
        maxHeight: 20 /* See: https://github.com/bpampuch/pdfmake/issues/264#issuecomment-108347567 */,
      },
      {
        columns: [
          `ID: ${person.registrantId}`,
          {
            text: person.wcaId ? `WCA ID: ${person.wcaId}` : {},
            alignment: 'right',
          },
        ],
      },
      {
        table: {
          widths: ['auto', ...headers.map(() => '*')],
          body: [
            [
              'Event',
              ...headers.map(header => ({ text: header, alignment: 'center' })),
            ],
            ...events.map(event => [
              eventNameById(event.id),
              ...assignmentCodes.map(assignmentCode =>
                groupsText(event.id, assignmentCode)
              ),
            ]),
          ],
        },
        layout: {
          paddingLeft: () => 2,
          paddingRight: () => 2,
          paddingTop: () => 1,
          paddingBottom: () => 1,
        },
      },
      ...times(Math.max(0, 12 - events.length), () => ({
        text: ' ',
      })) /* Add some empty space if there are few events. */,
    ],
  };
};
